<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Particle Heart - Rose Night Pro</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background:#06000a; }
    canvas { position: fixed; inset: 0; width: 100%; height: 100%; display:block; }
    #err {
      position: fixed; left: 10px; right: 10px; top: 10px; z-index: 9999;
      padding: 10px 12px; border-radius: 10px;
      background: rgba(0,0,0,0.72); color: #ffd6e8;
      font: 12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space: pre-wrap; display: none;
    }
  </style>
</head>
<body>
<div id="err"></div>
<canvas id="c"></canvas>
<script>
(() => {
  const errEl = document.getElementById('err');
  function showErr(e) {
    try {
      const msg = typeof e === 'string' ? e : (e && (e.stack || e.message)) || String(e);
      errEl.style.display = 'block';
      errEl.textContent = msg;
    } catch {}
  }
  window.addEventListener('error', (ev) => showErr(ev.error || ev.message || ev));
  window.addEventListener('unhandledrejection', (ev) => showErr(ev.reason || ev));

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  const reducedMotion =
    window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  const cfg = {
    dprCap: reducedMotion ? 1.0 : 1.75,

    maxParticles: reducedMotion ? 320 : 740,
    spawnPerFrame: reducedMotion ? 4 : 10,

    heartScale: 14.9,
    gatherStrength: 1.08,
    jitter: 0.26,

    baseSpreadX: 22,
    baseSpreadY: 10,
    initialUpMin: -260,
    initialUpMax: -130,

    trailAlpha: reducedMotion ? 0.30 : 0.24,     // 更暗更对比：尾迹更快收
    lighter: !reducedMotion,

    spriteSize: reducedMotion ? 128 : 192,
    drawSizeMin: 8,
    drawSizeMax: 14,

    stardustCount: reducedMotion ? 55 : 140,
    ribbonCount: reducedMotion ? 0 : 3,

    bokehCount: reducedMotion ? 10 : 18,
    petalCount: reducedMotion ? 0 : 22,

    bloomScale: reducedMotion ? 0.45 : 0.55,
    bloomBlur: reducedMotion ? 10 : 15,
    bloomAlpha: reducedMotion ? 0.62 : 0.76,

    haloAlpha: reducedMotion ? 0.12 : 0.18,
    ribbonAlpha: reducedMotion ? 0.10 : 0.18,

    drift: reducedMotion ? 0.0 : 5.0
  };

  let w = 0, h = 0, dpr = 1;

  const bloomCanvas = document.createElement('canvas');
  const bctx = bloomCanvas.getContext('2d', { alpha: true });

  const noiseCanvas = document.createElement('canvas');
  const nctx = noiseCanvas.getContext('2d', { alpha: true });
  let noisePattern = null;

  function rand(min, max) { return Math.random() * (max - min) + min; }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function basePos() { return { x: w * 0.5, y: h * 0.78 }; }
  function heartCenter() { return { x: w * 0.5, y: h * 0.58 }; }

  function buildNoiseTile() {
    const s = 128;
    noiseCanvas.width = noiseCanvas.height = s;
    const img = nctx.createImageData(s, s);
    for (let i = 0; i < img.data.length; i += 4) {
      const v = (Math.random() * 255) | 0;
      img.data[i + 0] = v;
      img.data[i + 1] = v;
      img.data[i + 2] = v;
      img.data[i + 3] = (Math.random() * 18) | 0; // 夜景更干净
    }
    nctx.putImageData(img, 0, 0);
    noisePattern = ctx.createPattern(noiseCanvas, 'repeat');
  }
  buildNoiseTile();

  let bgGradient = null;
  let vignette = null;

  function resize() {
    const realDpr = window.devicePixelRatio || 1;
    dpr = Math.max(1, Math.min(cfg.dprCap, realDpr));
    w = Math.floor(window.innerWidth);
    h = Math.floor(window.innerHeight);

    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    bloomCanvas.width = Math.floor(w * cfg.bloomScale * dpr);
    bloomCanvas.height = Math.floor(h * cfg.bloomScale * dpr);
    bctx.setTransform(cfg.bloomScale * dpr, 0, 0, cfg.bloomScale * dpr, 0, 0);
    bctx.imageSmoothingEnabled = true;
    bctx.imageSmoothingQuality = 'high';

    const hc = heartCenter();
    bgGradient = ctx.createRadialGradient(hc.x, hc.y, 0, hc.x, hc.y, Math.min(w, h) * 0.82);
    bgGradient.addColorStop(0.00, 'rgba(120, 10, 60, 0.18)');  // 酒红雾
    bgGradient.addColorStop(0.28, 'rgba(170, 18, 120, 0.12)'); // 深粉紫
    bgGradient.addColorStop(0.58, 'rgba(25, 6, 40, 0.06)');    // 深紫暗部
    bgGradient.addColorStop(1.00, 'rgba(0, 0, 0, 0.00)');

    vignette = ctx.createRadialGradient(w * 0.5, h * 0.55, Math.min(w, h) * 0.10,
                                        w * 0.5, h * 0.55, Math.min(w, h) * 0.82);
    vignette.addColorStop(0.0, 'rgba(0,0,0,0)');
    vignette.addColorStop(0.55, 'rgba(0,0,0,0.22)');
    vignette.addColorStop(1.0, 'rgba(0,0,0,0.78)');
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  function heartXY(t) {
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    return { x, y };
  }

  function heartToScreen(x, y, driftX = 0, driftY = 0) {
    const c = heartCenter();
    return { x: c.x + x * cfg.heartScale + driftX, y: c.y - y * cfg.heartScale + driftY };
  }

  const targets = [];
  function rebuildTargets() {
    targets.length = 0;
    const count = 2200;
    for (let i = 0; i < count; i++) {
      const t = rand(0, Math.PI * 2);
      const p = heartXY(t);
      const r = Math.pow(Math.random(), 0.28);
      targets.push({ x: p.x * r, y: p.y * r });
    }
  }
  rebuildTargets();
  function randomTarget() { return targets[(Math.random() * targets.length) | 0]; }

  function makeSpriteRGBA(r, g, b) {
    const s = cfg.spriteSize;
    const off = document.createElement('canvas');
    off.width = off.height = s;
    const g2 = off.getContext('2d');
    g2.imageSmoothingEnabled = true;
    g2.imageSmoothingQuality = 'high';

    const cx = s / 2, cy = s / 2;
    const grad = g2.createRadialGradient(cx, cy, 0, cx, cy, s / 2);
    grad.addColorStop(0.00, `rgba(255,255,255,0.95)`);
    grad.addColorStop(0.14, `rgba(${r},${g},${b},0.66)`);
    grad.addColorStop(0.48, `rgba(${r},${g},${b},0.18)`);
    grad.addColorStop(1.00, `rgba(0,0,0,0)`);
    g2.fillStyle = grad;
    g2.fillRect(0, 0, s, s);
    return off;
  }

  function makeSoftBokehSprite(r, g, b) {
    const s = 256;
    const off = document.createElement('canvas');
    off.width = off.height = s;
    const g2 = off.getContext('2d');
    const cx = s / 2, cy = s / 2;
    const grad = g2.createRadialGradient(cx, cy, 0, cx, cy, s / 2);
    grad.addColorStop(0.00, `rgba(${r},${g},${b},0.35)`);
    grad.addColorStop(0.22, `rgba(${r},${g},${b},0.18)`);
    grad.addColorStop(0.55, `rgba(${r},${g},${b},0.07)`);
    grad.addColorStop(1.00, `rgba(0,0,0,0)`);
    g2.fillStyle = grad;
    g2.fillRect(0, 0, s, s);
    return off;
  }

  function makePetalSprite() {
    const s = 96;
    const off = document.createElement('canvas');
    off.width = off.height = s;
    const g2 = off.getContext('2d');
    g2.translate(s/2, s/2);

    const grad = g2.createRadialGradient(-8, -10, 2, 0, 0, s/2);
    grad.addColorStop(0.00, 'rgba(255, 230, 245, 0.95)');
    grad.addColorStop(0.22, 'rgba(255, 120, 190, 0.70)');
    grad.addColorStop(0.55, 'rgba(200, 40, 200, 0.35)');
    grad.addColorStop(1.00, 'rgba(0,0,0,0)');

    g2.fillStyle = grad;
    g2.beginPath();
    g2.ellipse(0, 2, 18, 28, 0.35, 0, Math.PI * 2);
    g2.fill();

    g2.globalAlpha = 0.35;
    g2.strokeStyle = 'rgba(255,255,255,0.55)';
    g2.lineWidth = 1.2;
    g2.beginPath();
    g2.moveTo(-3, -18);
    g2.quadraticCurveTo(6, -6, 2, 18);
    g2.stroke();

    return off;
  }

  const sprites = [
    makeSpriteRGBA(255, 70, 150),   // 玫瑰粉
    makeSpriteRGBA(230, 50, 210),   // 玫紫
    makeSpriteRGBA(190, 25, 255),   // 深紫
    makeSpriteRGBA(255, 135, 195),  // 柔粉高光
    makeSpriteRGBA(160, 10, 70)     // 莓红暗部
  ];

  const bokehSprites = [
    makeSoftBokehSprite(255, 70, 150),
    makeSoftBokehSprite(230, 50, 210),
    makeSoftBokehSprite(190, 25, 255)
  ];

  const petalSprite = makePetalSprite();

  class Particle {
    constructor() { this.reset(); }
    reset() {
      const b = basePos();
      this.x = b.x + rand(-cfg.baseSpreadX, cfg.baseSpreadX);
      this.y = b.y + rand(-cfg.baseSpreadY, cfg.baseSpreadY);
      this.vx = rand(-32, 32);
      this.vy = rand(cfg.initialUpMin, cfg.initialUpMax);
      this.life = 0;
      this.lifeMax = rand(2.7, 5.0);
      this.target = randomTarget();
      this.phase = rand(0, Math.PI * 2);
      this.size = rand(cfg.drawSizeMin, cfg.drawSizeMax);
      this.sprite = sprites[(Math.random() * sprites.length) | 0];
      this.alpha = rand(0.42, 0.96);
    }
    update(dt, tSec, driftX, driftY) {
      this.life += dt;
      const t = this.life / this.lifeMax;

      const tp = heartToScreen(
        this.target.x + Math.sin(this.phase + tSec * 1.9) * cfg.jitter,
        this.target.y + Math.cos(this.phase + tSec * 1.6) * cfg.jitter,
        driftX, driftY
      );

      const gather = clamp((t - 0.12) / 0.88, 0, 1);
      const k = cfg.gatherStrength * (0.9 + 0.85 * gather);

      const dx = tp.x - this.x;
      const dy = tp.y - this.y;

      this.vx += dx * k * dt;
      this.vy += dy * k * dt;
      this.vy += (-145 * (1 - gather)) * dt;

      this.vx *= Math.pow(0.14, dt);
      this.vy *= Math.pow(0.16, dt);

      this.x += this.vx * dt;
      this.y += this.vy * dt;

      const fadeIn = clamp(t / 0.10, 0, 1);
      const fadeOut = 1 - clamp((t - 0.90) / 0.10, 0, 1);
      this.a = this.alpha * fadeIn * fadeOut;

      return this.life < this.lifeMax;
    }
    draw(mainCtx, tSec, extraGlow = false) {
      const twinkle = 0.76 + 0.24 * Math.sin(this.phase + tSec * 6.0);
      mainCtx.globalAlpha = this.a * twinkle;

      const s = this.size;
      mainCtx.drawImage(this.sprite, this.x - s/2, this.y - s/2, s, s);

      mainCtx.globalAlpha = this.a * (extraGlow ? 0.60 : 0.44);
      mainCtx.fillStyle = 'rgba(255,245,250,0.92)';
      mainCtx.fillRect(this.x - 0.6, this.y - 0.6, 1.2, 1.2);
    }
  }

  class Stardust {
    constructor() { this.reset(true); }
    reset(initial = false) {
      this.phase = rand(0, Math.PI * 2);
      this.angle = rand(0, Math.PI * 2);
      this.speed = rand(0.48, 1.10) * (Math.random() < 0.5 ? -1 : 1);
      this.depth = Math.pow(Math.random(), 1.6);
      this.size = rand(2.0, 5.0) * (1.12 - this.depth * 0.58);
      this.alpha = rand(0.12, 0.44) * (1.0 - this.depth * 0.35);
      this.sprite = sprites[(Math.random() * sprites.length) | 0];
      this.wobble = rand(2, 10) * (1.0 - this.depth * 0.6);
      if (!initial) this.angle = rand(0, Math.PI * 2);
    }
    update(dt, tSec, driftX, driftY) {
      const m = Math.min(w, h);
      const baseR = m * (0.11 + this.depth * 0.05);
      const rangeR = m * (0.31 + this.depth * 0.06);
      const wob = Math.sin(this.phase + tSec * 1.9) * this.wobble;
      const r = baseR + (1 - this.depth) * rangeR + wob;

      this.angle += this.speed * dt * (0.9 + (1 - this.depth) * 0.55);

      const hc = heartCenter();
      this.x = hc.x + Math.cos(this.angle) * r * 1.10 + driftX * (0.32 + (1 - this.depth) * 0.26);
      this.y = hc.y + Math.sin(this.angle) * r * 0.68 - (1 - this.depth) * (m * 0.10)
             + driftY * (0.32 + (1 - this.depth) * 0.26);

      const tw = 0.72 + 0.28 * Math.sin(this.phase + tSec * (6.6 + (1 - this.depth) * 1.8));
      this.a = this.alpha * tw;
    }
    draw(mainCtx) {
      mainCtx.globalAlpha = this.a;
      const s = this.size;
      mainCtx.drawImage(this.sprite, this.x - s/2, this.y - s/2, s, s);
    }
  }

  class Bokeh {
    constructor() { this.reset(true); }
    reset(initial = false) {
      this.sprite = bokehSprites[(Math.random() * bokehSprites.length) | 0];
      this.r = rand(Math.min(w,h) * 0.10, Math.min(w,h) * 0.22);
      this.x = rand(-this.r, w + this.r);
      this.y = rand(-this.r, h + this.r);
      this.vx = rand(-8, 8);
      this.vy = rand(-6, 10);
      this.alpha = rand(0.08, 0.18);
      this.phase = rand(0, Math.PI * 2);
      if (!initial) {
        this.x = rand(-this.r, w + this.r);
        this.y = h + this.r;
      }
    }
    update(dt, tSec) {
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      const pulse = 0.86 + 0.14 * Math.sin(this.phase + tSec * 0.7);
      this.a = this.alpha * pulse;

      if (this.x < -this.r * 1.2 || this.x > w + this.r * 1.2 || this.y < -this.r * 1.2 || this.y > h + this.r * 1.2) {
        this.reset(false);
      }
    }
    draw(mainCtx) {
      mainCtx.globalAlpha = this.a;
      const s = this.r * 2;
      mainCtx.drawImage(this.sprite, this.x - this.r, this.y - this.r, s, s);
    }
  }

  class Petal {
    constructor() { this.reset(true); }
    reset(initial = false) {
      this.x = rand(0, w);
      this.y = initial ? rand(0, h) : -rand(20, 180);
      this.vx = rand(-18, 18);
      this.vy = rand(26, 52);
      this.rot = rand(0, Math.PI * 2);
      this.rotSpd = rand(-1.8, 1.8);
      this.size = rand(18, 42);
      this.alpha = rand(0.08, 0.20);
      this.phase = rand(0, Math.PI * 2);
    }
    update(dt, tSec, driftX) {
      const sway = Math.sin(this.phase + tSec * 1.2) * 10;
      this.x += (this.vx + sway) * dt + driftX * 0.10 * dt;
      this.y += this.vy * dt;
      this.rot += this.rotSpd * dt;

      if (this.x < -80) this.x = w + 80;
      if (this.x > w + 80) this.x = -80;
      if (this.y > h + 100) this.reset(false);
    }
    draw(mainCtx, extraGlow = false) {
      mainCtx.save();
      mainCtx.globalAlpha = this.alpha * (extraGlow ? 0.8 : 1.0);
      mainCtx.translate(this.x, this.y);
      mainCtx.rotate(this.rot);
      const s = this.size;
      mainCtx.drawImage(petalSprite, -s/2, -s/2, s, s);
      mainCtx.restore();
    }
  }

  const particles = [];
  const dust = [];
  const bokehs = [];
  const petals = [];

  function ensureParticles(add) {
    const want = Math.min(cfg.maxParticles, particles.length + add);
    while (particles.length < want) particles.push(new Particle());
  }
  function initDust() {
    dust.length = 0;
    for (let i = 0; i < cfg.stardustCount; i++) dust.push(new Stardust());
  }
  function initBokeh() {
    bokehs.length = 0;
    for (let i = 0; i < cfg.bokehCount; i++) bokehs.push(new Bokeh());
  }
  function initPetals() {
    petals.length = 0;
    for (let i = 0; i < cfg.petalCount; i++) petals.push(new Petal());
  }

  ensureParticles(reducedMotion ? 200 : 580);
  initDust();
  initBokeh();
  initPetals();

  function drawBase(mainCtx, tSec) {
    const b = basePos();
    mainCtx.save();
    mainCtx.globalCompositeOperation = cfg.lighter ? 'lighter' : 'source-over';

    const outerR = Math.min(w, h) * 0.115;
    const innerR = outerR * 0.18;

    const g = mainCtx.createRadialGradient(b.x, b.y, innerR, b.x, b.y, outerR);
    g.addColorStop(0.00, `rgba(255, 90, 170, 0.58)`);
    g.addColorStop(0.30, `rgba(230, 50, 210, 0.22)`);
    g.addColorStop(0.70, `rgba(190, 25, 255, 0.10)`);
    g.addColorStop(1.00, `rgba(0, 0, 0, 0)`);

    mainCtx.fillStyle = g;
    mainCtx.beginPath();
    mainCtx.ellipse(b.x, b.y, outerR * 1.22, outerR * 0.40, 0, 0, Math.PI * 2);
    mainCtx.fill();

    mainCtx.globalAlpha = 0.68;
    mainCtx.strokeStyle = `rgba(255, 135, 195, 0.44)`;
    mainCtx.lineWidth = 2;
    const rot = tSec * 0.9;
    mainCtx.beginPath();
    mainCtx.ellipse(b.x, b.y, outerR * 0.82, outerR * 0.26, rot, 0, Math.PI * 2);
    mainCtx.stroke();

    mainCtx.strokeStyle = `rgba(190, 25, 255, 0.32)`;
    mainCtx.beginPath();
    mainCtx.ellipse(b.x, b.y, outerR * 0.62, outerR * 0.20, -rot * 1.12, 0, Math.PI * 2);
    mainCtx.stroke();

    mainCtx.restore();
  }

  function drawHalo(mainCtx, tSec, driftX, driftY) {
    const hc = heartCenter();
    const m = Math.min(w, h);
    const r2 = m * 0.30;

    mainCtx.save();
    mainCtx.globalCompositeOperation = cfg.lighter ? 'lighter' : 'source-over';

    const pulse = 0.86 + 0.14 * Math.sin(tSec * 1.25);
    mainCtx.globalAlpha = cfg.haloAlpha * pulse;

    const gx = hc.x + driftX * 0.55;
    const gy = hc.y + driftY * 0.55;

    const grad = mainCtx.createRadialGradient(gx, gy, 0, gx, gy, r2 * 1.10);
    grad.addColorStop(0.00, 'rgba(255, 70, 150, 0.00)');
    grad.addColorStop(0.30, 'rgba(255, 70, 150, 0.10)');
    grad.addColorStop(0.56, 'rgba(230, 50, 210, 0.12)');
    grad.addColorStop(0.78, 'rgba(190, 25, 255, 0.10)');
    grad.addColorStop(1.00, 'rgba(0,0,0,0)');

    mainCtx.fillStyle = grad;
    mainCtx.beginPath();
    mainCtx.ellipse(gx, gy, r2 * 1.12, r2 * 0.80, 0, 0, Math.PI * 2);
    mainCtx.fill();

    const rotA = tSec * 0.50;
    const rotB = -tSec * 0.68;

    mainCtx.lineWidth = 2;
    mainCtx.globalAlpha *= 0.95;

    mainCtx.strokeStyle = 'rgba(255, 135, 195, 0.26)';
    mainCtx.beginPath();
    mainCtx.ellipse(gx, gy, r2 * 1.06, r2 * 0.68, rotA, 0, Math.PI * 2);
    mainCtx.stroke();

    mainCtx.strokeStyle = 'rgba(190, 25, 255, 0.24)';
    mainCtx.beginPath();
    mainCtx.ellipse(gx, gy, r2 * 0.88, r2 * 0.56, rotB, 0, Math.PI * 2);
    mainCtx.stroke();

    mainCtx.restore();
  }

  function drawRibbons(mainCtx, tSec, driftX, driftY) {
    if (cfg.ribbonCount <= 0) return;

    const hc = heartCenter();
    const m = Math.min(w, h);
    const minR = m * 0.08;
    const maxR = m * 0.37;

    mainCtx.save();
    mainCtx.globalCompositeOperation = cfg.lighter ? 'lighter' : 'source-over';
    mainCtx.globalAlpha = cfg.ribbonAlpha;
    mainCtx.lineCap = 'round';
    mainCtx.lineJoin = 'round';

    for (let i = 0; i < cfg.ribbonCount; i++) {
      const dir = (i % 2 === 0) ? 1 : -1;
      const speed = (0.50 + i * 0.18) * dir;
      const turns = 1.65 + i * 0.22;
      const tilt = 0.72 + i * 0.03;

      const steps = 140;
      const pts = new Array(steps);

      for (let j = 0; j < steps; j++) {
        const u = j / (steps - 1);
        const ang = (tSec * speed) + u * turns * Math.PI * 2 + i * 2.0;
        const wob = Math.sin(tSec * 1.9 + u * 9.5 + i) * 10;
        const r = minR + u * (maxR - minR) + wob;

        const x = hc.x + Math.cos(ang) * r * 1.10 + driftX * (0.55 - u * 0.18);
        const y = hc.y + Math.sin(ang) * r * tilt - u * (m * 0.085) + driftY * (0.55 - u * 0.18);

        pts[j] = { x, y };
      }

      mainCtx.beginPath();
      mainCtx.moveTo(pts[0].x, pts[0].y);
      for (let j = 1; j < pts.length - 2; j++) {
        const cpx = pts[j].x;
        const cpy = pts[j].y;
        const nx = (pts[j].x + pts[j + 1].x) / 2;
        const ny = (pts[j].y + pts[j + 1].y) / 2;
        mainCtx.quadraticCurveTo(cpx, cpy, nx, ny);
      }
      mainCtx.quadraticCurveTo(
        pts[pts.length - 2].x, pts[pts.length - 2].y,
        pts[pts.length - 1].x, pts[pts.length - 1].y
      );

      const first = pts[0], last = pts[pts.length - 1];
      const grad = mainCtx.createLinearGradient(first.x, first.y, last.x, last.y);
      grad.addColorStop(0.00, 'rgba(160, 10, 70, 0.00)');
      grad.addColorStop(0.16, 'rgba(255, 70, 150, 0.62)');
      grad.addColorStop(0.46, 'rgba(230, 50, 210, 0.50)');
      grad.addColorStop(0.74, 'rgba(190, 25, 255, 0.40)');
      grad.addColorStop(1.00, 'rgba(0, 0, 0, 0.00)');

      mainCtx.strokeStyle = grad;
      mainCtx.lineWidth = 1.7 + i * 0.45;
      mainCtx.stroke();
    }

    mainCtx.restore();
  }

  function drawBackground(tSec) {
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';

    ctx.fillStyle = `rgba(6,0,10,${cfg.trailAlpha})`;
    ctx.fillRect(0, 0, w, h);

    if (bgGradient) {
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = bgGradient;
      ctx.fillRect(0, 0, w, h);
    }

    // 轻雾（让暗部更高级）
    const mist = ctx.createLinearGradient(0, 0, 0, h);
    mist.addColorStop(0.00, 'rgba(0,0,0,0.00)');
    mist.addColorStop(0.35, 'rgba(50,0,40,0.06)');
    mist.addColorStop(1.00, 'rgba(0,0,0,0.00)');
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = mist;
    ctx.fillRect(0, 0, w, h);

    if (noisePattern) {
      ctx.save();
      ctx.globalAlpha = 0.10;
      const ox = (tSec * 22) % 128;
      const oy = (tSec * 16) % 128;
      ctx.translate(-ox, -oy);
      ctx.fillStyle = noisePattern;
      ctx.fillRect(ox, oy, w + 128, h + 128);
      ctx.restore();
    }

    if (vignette) {
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, w, h);
    }

    ctx.restore();
  }

  let last = performance.now();
  function frame(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    const tSec = now / 1000;

    const driftX = cfg.drift * Math.sin(tSec * 0.33);
    const driftY = cfg.drift * Math.cos(tSec * 0.29);

    // 1) 背景
    drawBackground(tSec);

    // 2) Glow 层（bloomCanvas）
    bctx.save();
    bctx.globalCompositeOperation = 'source-over';
    bctx.fillStyle = 'rgba(0,0,0,0.24)';
    bctx.fillRect(0, 0, w, h);

    // bokeh 先画在 glow 层（会被 blur，质感更好）
    bctx.globalCompositeOperation = cfg.lighter ? 'lighter' : 'screen';
    for (let i = 0; i < bokehs.length; i++) {
      bokehs[i].update(dt, tSec);
      bokehs[i].draw(bctx);
    }

    drawHalo(bctx, tSec, driftX, driftY);
    drawRibbons(bctx, tSec, driftX, driftY);

    bctx.globalCompositeOperation = cfg.lighter ? 'lighter' : 'source-over';
    for (let i = 0; i < dust.length; i++) {
      dust[i].update(dt, tSec, driftX, driftY);
      dust[i].draw(bctx);
    }

    if (petals.length) {
      for (let i = 0; i < petals.length; i++) {
        petals[i].update(dt, tSec, driftX);
        petals[i].draw(bctx, true);
      }
    }

    ensureParticles(cfg.spawnPerFrame);
    for (let i = 0; i < particles.length; i += 2) {
      const p = particles[i];
      if (!p.update(dt, tSec, driftX, driftY)) p.reset();
      p.draw(bctx, tSec, true);
    }
    bctx.restore();

    // 3) Bloom 叠加到主画布
    ctx.save();
    ctx.globalCompositeOperation = cfg.lighter ? 'lighter' : 'screen';
    ctx.globalAlpha = cfg.bloomAlpha;
    ctx.filter = `blur(${cfg.bloomBlur}px)`;
    ctx.drawImage(bloomCanvas, 0, 0, w, h);
    ctx.restore();

    // 4) 清晰层
    ctx.save();
    ctx.globalCompositeOperation = cfg.lighter ? 'lighter' : 'source-over';
    drawHalo(ctx, tSec, driftX, driftY);
    drawRibbons(ctx, tSec, driftX, driftY);

    // 让星尘更“点亮”但不抢
    for (let i = 0; i < dust.length; i++) dust[i].draw(ctx);

    // 花瓣清晰层
    if (petals.length) {
      for (let i = 0; i < petals.length; i++) petals[i].draw(ctx, false);
    }

    drawBase(ctx, tSec);

    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      if ((i & 1) === 1) {
        if (!p.update(dt, tSec, driftX, driftY)) p.reset();
      }
      p.draw(ctx, tSec, false);
    }

    ctx.restore();
    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);

  // 快捷键：1 暗黑玫瑰 / 2 推荐 / 3 更闪更华丽
  window.addEventListener('keydown', (e) => {
    if (e.key === '1') {
      cfg.trailAlpha = 0.28;
      cfg.bloomBlur = 14; cfg.bloomAlpha = 0.70;
      cfg.ribbonCount = 2; cfg.ribbonAlpha = 0.16;
      cfg.maxParticles = 640; cfg.spawnPerFrame = 8;
      cfg.stardustCount = 110; cfg.bokehCount = 14; cfg.petalCount = 18;
      initDust(); initBokeh(); initPetals(); resize();
    }
    if (e.key === '2') {
      cfg.trailAlpha = 0.24;
      cfg.bloomBlur = 15; cfg.bloomAlpha = 0.76;
      cfg.ribbonCount = 3; cfg.ribbonAlpha = 0.18;
      cfg.maxParticles = 740; cfg.spawnPerFrame = 10;
      cfg.stardustCount = 140; cfg.bokehCount = 18; cfg.petalCount = 22;
      initDust(); initBokeh(); initPetals(); resize();
    }
    if (e.key === '3') {
      cfg.trailAlpha = 0.22;
      cfg.bloomBlur = 17; cfg.bloomAlpha = 0.80;
      cfg.ribbonCount = 4; cfg.ribbonAlpha = 0.20;
      cfg.maxParticles = 880; cfg.spawnPerFrame = 12;
      cfg.stardustCount = 180; cfg.bokehCount = 22; cfg.petalCount = 28;
      initDust(); initBokeh(); initPetals(); resize();
    }
  });
})();
</script>
</body>
</html>
