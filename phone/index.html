<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>给宝宝的小情书</title>

  <style>
    :root { color-scheme: dark; }

    html,body{
      height:100%;
      margin:0;
      overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      -webkit-tap-highlight-color: transparent;
    }

    body{
      min-height:100dvh;
      background:
        radial-gradient(900px 600px at 20% 10%, #2a1030 0%, transparent 55%),
        radial-gradient(900px 600px at 80% 20%, #0b2a3a 0%, transparent 55%),
        #05060a;
      color:#fff;
    }

    #layer{
      position:fixed;
      inset:0;
      height:100dvh;
      z-index:9999;
    }

    :root{
      --popup-w: clamp(104px, 28vw, 150px);
      --popup-h: clamp(66px, 9.2vh, 98px);
      --bar-h: 26px;
      --radius: 12px;
      --font: clamp(10px, 1.12vh, 11.5px);
    }

    @media (min-width: 900px){
      :root{
        --popup-w: 180px;
        --popup-h: 110px;
        --bar-h: 32px;
        --radius: 14px;
        --font: 13.5px;
      }
    }

    .popup{
      position:fixed;
      width:var(--popup-w);
      height:var(--popup-h);
      border-radius:var(--radius);
      background:rgba(18,20,28,.66);
      border:2px solid rgba(255,255,255,.18);
      box-shadow:0 18px 55px rgba(0,0,0,.45);
      overflow:hidden;
      transform: translate(-50%, -50%);
      touch-action: manipulation;
      user-select:none;
    }

    .popup.dragging{ will-change:left, top, transform; }

    .popup.focused{
      outline:2px solid rgba(255,255,255,.16);
      box-shadow:0 22px 70px rgba(0,0,0,.55);
    }

    .bar{
      height:var(--bar-h);
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 8px 0 10px;
      background:rgba(255,255,255,.06);
      border-bottom:1px solid rgba(255,255,255,.10);
      font-size:12px;
      color:rgba(255,255,255,.85);
      cursor:grab;
      touch-action:none;
      user-select:none;
    }
    .bar:active{ cursor:grabbing; }

    .close{
      width:24px;
      height:24px;
      border-radius:9px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.10);
      color:#fff;
      cursor:pointer;
      display:grid;
      place-items:center;
      font-size:16px;
      line-height:1;
      padding:0;
    }

    .content{
      height: calc(var(--popup-h) - var(--bar-h));
      display:grid;
      place-items:center;
      padding:7px 9px;
      text-align:center;
      font-size:var(--font);
      color:rgba(255,255,255,.95);
      user-select:text;
    }

    .popIn{ animation: popIn .48s cubic-bezier(.2,.9,.2,1) both; }
    @keyframes popIn{
      from{ opacity:0; transform:translate(-50%,-50%) scale(.80); }
      to{ opacity:1; transform:translate(-50%,-50%) scale(1); }
    }

    @media (prefers-reduced-motion: reduce){
      .popIn{ animation:none; }
      .popup{ transition:none !important; }
    }

    .toolbar{
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: calc(12px + env(safe-area-inset-bottom));
      z-index:10000;
      display:flex;
      gap:10px;
      justify-content:center;
      pointer-events:none;
    }
    .toolbar button{
      pointer-events:auto;
      min-height: 44px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(15,23,42,.65);
      color:#fff;
      font-weight: 800;
      backdrop-filter: blur(10px);
    }
  </style>
</head>

<body>
  <div id="layer"></div>

  <div class="toolbar">
    <button id="replay">重播</button>
    <button id="clear">清空</button>
  </div>

  <script>
    const layer = document.getElementById('layer');

    const params = new URLSearchParams(location.search);
    const nickname = (params.get('name') || "宝宝").trim() || "宝宝";

    const isMobile = matchMedia('(pointer: coarse)').matches || innerWidth < 520;

    const totalPopups = Math.max(10, Number(params.get('total') || 200));

    // 轮廓阶段：越少越“空灵”，越像“线条”
    const heartPopups = Math.min(
      totalPopups,
      Math.max(10, Number(params.get('heart') || (isMobile ? 60 : 180)))
    );

    // 越大越慢
    const defaultSpeed = isMobile ? 16 : 70;
    const appearIntervalMs = Math.max(8, Number(params.get('speed') || defaultSpeed));

    // 散落
    const scatterEnabled = (params.get('scatter') ?? '1') !== '0';
    const scatterDelayMs = Math.max(0, Number(params.get('scatterDelay') || (isMobile ? 2200 : 1200)));
    const scatterDurationMs = Math.max(200, Number(params.get('scatterDuration') || (isMobile ? 900 : 1000)));
    const extraSpawnGapMs = Math.max(0, Number(params.get('extraGap') || (isMobile ? 10 : 8)));

    // 如果你的页面顶部有固定栏挡住心形，可用 ?top=120 往下挪
    const topReserve = Math.max(0, Number(params.get('top') || 0));
    const bottomReserve = Math.max(0, Number(params.get('bottom') || (isMobile ? 102 : 0)));

    const words = [
      `好好吃饭，${nickname}，我会心疼。`,
      `早点睡觉，不许熬夜，听话。`,
      `我想你了，真的。`,
      `你忙你的，我乖乖想你。`,
      `你给我发条消息，我能开心一整天。`,
      `别逞强，难受就来找我。`,
      `你一笑，我就什么都原谅了。`,
      `不开心就冲我撒娇，我接住。`,
      `到家跟我说一声，乖。`,
      `我对你，心软得一塌糊涂。`,
      `别想太多，来想我。`,
      `你要记得：你有人惦记。`,
      `晚安，${nickname}，梦里也要想我。`,
    ];

    const TAU = Math.PI * 2;

    function rand(a, b) { return a + Math.random() * (b - a); }
    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function gcd(a, b) {
      a = Math.abs(a); b = Math.abs(b);
      while (b) { const t = a % b; a = b; b = t; }
      return a || 1;
    }

    // 让“出现过程”也像心：按跳步顺序铺满整圈
    function spreadOrder(n) {
      if (n <= 1) return [0];
      let step = Math.floor(n / 2);
      if (step % 2 === 0) step += 1;
      while (gcd(step, n) !== 1) step += 2;

      const out = new Array(n);
      let idx = 0;
      for (let i = 0; i < n; i++) {
        out[i] = idx;
        idx = (idx + step) % n;
      }
      return out;
    }

    // 标准心形参数方程
    function heartPoint(t) {
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
      return { x, y };
    }

    // 导数用于求切线/法线
    function heartDeriv(t) {
      const s = Math.sin(t), c = Math.cos(t);
      const dx = 48 * s * s * c;
      const dy = -13 * Math.sin(t) + 10 * Math.sin(2 * t) + 6 * Math.sin(3 * t) + 4 * Math.sin(4 * t);
      return { dx, dy };
    }

    // 弧长查表：用于“等距”取点，轮廓更稳更像
    let cachedLUT = null;
    function getHeartLUT(samples = 2600) {
      if (cachedLUT && cachedLUT.samples === samples) return cachedLUT;

      const points = new Array(samples + 1);
      const ts = new Float32Array(samples + 1);
      const lengths = new Float32Array(samples + 1);

      let total = 0;
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

      let prev = null;
      for (let i = 0; i <= samples; i++) {
        const t = (i / samples) * TAU;
        const p = heartPoint(t);

        points[i] = p;
        ts[i] = t;

        minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);

        if (prev) total += Math.hypot(p.x - prev.x, p.y - prev.y);
        lengths[i] = total;
        prev = p;
      }

      cachedLUT = {
        samples,
        points,
        ts,
        lengths,
        total,
        minX, maxX, minY, maxY,
        midX: (minX + maxX) / 2,
        midY: (minY + maxY) / 2,
        width: (maxX - minX),
        height: (maxY - minY),
      };
      return cachedLUT;
    }

    function sampleHeartByArc(lut, count, phase = 0) {
      const out = new Array(count);
      const step = lut.total / count;
      let seg = 0;

      for (let i = 0; i < count; i++) {
        const d = (i + phase) * step;

        while (seg < lut.samples - 1 && lut.lengths[seg + 1] < d) seg++;

        const d0 = lut.lengths[seg];
        const d1 = lut.lengths[seg + 1];
        const u = d1 === d0 ? 0 : (d - d0) / (d1 - d0);

        const p0 = lut.points[seg];
        const p1 = lut.points[seg + 1];
        const t0 = lut.ts[seg];
        const t1 = lut.ts[seg + 1];

        out[i] = {
          x: p0.x + (p1.x - p0.x) * u,
          y: p0.y + (p1.y - p0.y) * u,
          t: t0 + (t1 - t0) * u
        };
      }
      return out;
    }

    function borderColor() {
      const hue = Math.floor(rand(0, 360));
      return `hsl(${hue} 92% 65%)`;
    }

    let buildToken = 0;
    let timers = [];

    let topZ = 1000;
    function bringToFront(el) {
      topZ = Math.max(topZ + 1, Number(el.style.zIndex || 0) + 1);
      el.style.zIndex = String(topZ);
      el.classList.add('focused');
      setTimeout(() => el.classList.remove('focused'), 350);
    }

    function schedule(token, fn, ms) {
      const id = setTimeout(() => {
        if (token !== buildToken) return;
        fn();
      }, ms);
      timers.push(id);
    }

    function resetScene() {
      for (const id of timers) clearTimeout(id);
      timers = [];
      layer.replaceChildren();
    }

    function scatterPopups(token, popups, durationMs) {
      const margin = 10;

      for (const el of popups) {
        if (!el || !el.isConnected) continue;

        const rect = el.getBoundingClientRect();
        const halfW = rect.width / 2;
        const halfH = rect.height / 2;

        const x = rand(halfW + margin, innerWidth - halfW - margin);
        const y = rand(halfH + margin, innerHeight - halfH - margin);
        const rot = rand(-16, 16);

        el.style.transition =
          `left ${durationMs}ms cubic-bezier(.2,.9,.2,1), ` +
          `top ${durationMs}ms cubic-bezier(.2,.9,.2,1), ` +
          `transform ${durationMs}ms cubic-bezier(.2,.9,.2,1)`;

        requestAnimationFrame(() => {
          if (token !== buildToken || !el.isConnected) return;
          el.style.left = x + 'px';
          el.style.top = y + 'px';
          el.style.transform = `translate(-50%, -50%) scale(1) rotate(${rot}deg)`;
        });
      }

      schedule(token, () => {
        for (const el of popups) {
          if (!el || !el.isConnected) continue;
          el.style.transition = '';
        }
      }, durationMs + 40);
    }

    function makePopup({ cx, cy, text, z }) {
      const el = document.createElement('div');
      el.className = 'popup popIn';
      el.style.left = cx + 'px';
      el.style.top = cy + 'px';
      el.style.zIndex = String(z);
      el.style.borderColor = borderColor();
      topZ = Math.max(topZ, z);

      el.innerHTML = `
        <div class="bar">
          <span>♡ ${nickname}</span>
          <button class="close" aria-label="关闭">×</button>
        </div>
        <div class="content"></div>
      `;
      el.querySelector('.content').textContent = text;

      el.addEventListener('pointerdown', () => bringToFront(el), { passive: true });

      const closeBtn = el.querySelector('.close');
      closeBtn.addEventListener('pointerdown', (e) => e.stopPropagation(), { passive: true });
      closeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        el.remove();
      });

      const bar = el.querySelector('.bar');
      let dragging = false;
      let dx = 0, dy = 0;

      bar.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        dragging = true;
        el.classList.add('dragging');
        el.setPointerCapture(e.pointerId);

        bringToFront(el);
        el.style.transition = '';
        el.style.transform = 'translate(-50%, -50%) scale(1)';

        const rect = el.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        dx = e.clientX - centerX;
        dy = e.clientY - centerY;
      });

      el.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        const nextCx = clamp(e.clientX - dx, 20, innerWidth - 20);
        const nextCy = clamp(e.clientY - dy, 20, innerHeight - 20);
        el.style.left = nextCx + 'px';
        el.style.top = nextCy + 'px';
      });

      function stopDrag(){
        dragging = false;
        el.classList.remove('dragging');
      }
      el.addEventListener('pointerup', stopDrag);
      el.addEventListener('pointercancel', stopDrag);

      layer.appendChild(el);
      return el;
    }

    function measurePopupSize() {
      const probe = document.createElement('div');
      probe.className = 'popup';
      probe.style.left = '-9999px';
      probe.style.top = '-9999px';
      probe.style.visibility = 'hidden';
      probe.style.pointerEvents = 'none';
      probe.innerHTML = `
        <div class="bar"><span>♡</span><button class="close">×</button></div>
        <div class="content">test</div>
      `;
      document.body.appendChild(probe);
      const rect = probe.getBoundingClientRect();
      probe.remove();
      return { w: rect.width, h: rect.height };
    }

    function buildHeart() {
      buildToken++;
      const token = buildToken;

      resetScene();

      const W = innerWidth;
      const H = innerHeight;

      const { w: popupW, h: popupH } = measurePopupSize();
      const margin = 10;

      const lut = getHeartLUT(2600);

      // 基础拉伸：让两瓣更展开、整体更心形
      const xStretchBase = isMobile ? 1.32 : 1.12;
      const yStretchBase = isMobile ? 1.12 : 1.04;

      // 留白时按“有效占位”估计，避免因为弹窗宽高导致心形压扁
      const effectiveW = popupW * 0.60;
      const effectiveH = popupH * 0.60;

      const availH = Math.max(120, H - topReserve - bottomReserve);
      const usableW = Math.max(80, W - 2 * margin - effectiveW);
      const usableH = Math.max(80, availH - 2 * margin - effectiveH);

      const scale = 0.98 * Math.min(
        usableW / (lut.width * xStretchBase),
        usableH / (lut.height * yStretchBase)
      );

      const centerX = W / 2;
      const centerY = topReserve + availH / 2 + (isMobile ? 6 : 10);

      // 手机用单圈更清晰更像“轮廓”；桌面可 3 圈更厚实
      const ringOffsetsPx = isMobile ? [0] : [-16, 0, 16];
      const ringCount = ringOffsetsPx.length;

      const base = Math.floor(heartPopups / ringCount);
      const rem = heartPopups % ringCount;

      const outlineItems = [];
      for (let r = 0; r < ringCount; r++) {
        const count = base + (r < rem ? 1 : 0);
        const phase = (r / ringCount) * 0.45;

        const pts = sampleHeartByArc(lut, count, phase);
        const off = ringOffsetsPx[r];

        for (const p of pts) {
          const yRel = (p.y - lut.midY) / (lut.height / 2);

          // 下半部分（yRel < 0）：收窄 X + 略拉长 Y => 底部更尖
          // 上半部分（yRel > 0）：略展开 X => 两瓣更明显
          const bottomNarrow = clamp(1 + yRel * 0.28, 0.65, 1.15);
          const topWiden = clamp(1 + yRel * 0.10, 0.95, 1.18);

          const xStretch = xStretchBase * (yRel < 0 ? bottomNarrow : topWiden);
          const yStretch = yStretchBase * (yRel < 0 ? 1.10 : 1.02);

          const dx = (p.x - lut.midX) * scale * xStretch;
          const dy = (p.y - lut.midY) * scale * yStretch;

          const d = heartDeriv(p.t);
          const tx = d.dx * xStretch;
          const ty = d.dy * yStretch;

          // 法线偏移（用于多圈轮廓）
          let nx = -ty, ny = tx;
          const nl = Math.hypot(nx, ny) || 1;
          nx /= nl; ny /= nl;

          const cx = centerX + dx + nx * off;
          const cy = centerY - dy - ny * off; // y 轴翻转

          outlineItems.push({ cx, cy });
        }
      }

      const orderIdx = spreadOrder(outlineItems.length);

      const pool = shuffle([...words]);
      let textIndex = 0;

      const created = [];
      let order = 0;

      for (const idx of orderIdx) {
        const { cx, cy } = outlineItems[idx];
        const text = pool[textIndex++ % pool.length];
        const delay = order * appearIntervalMs;
        const z = 10 + order;
        order++;

        schedule(token, () => {
          created.push(makePopup({ cx, cy, text, z }));
        }, delay);
      }

      const lastDelay = Math.max(0, (order - 1) * appearIntervalMs);

      if (scatterEnabled) {
        schedule(token, () => {
          scatterPopups(token, created, scatterDurationMs);

          const need = Math.max(0, totalPopups - outlineItems.length);
          const halfW = popupW / 2;
          const halfH = popupH / 2;

          for (let k = 0; k < need; k++) {
            schedule(token, () => {
              const x = rand(halfW + margin, innerWidth - halfW - margin);
              const y = rand(halfH + margin, innerHeight - halfH - margin);
              const text = pool[textIndex++ % pool.length];
              makePopup({ cx: x, cy: y, text, z: 10 + order++ });
            }, k * extraSpawnGapMs);
          }
        }, lastDelay + scatterDelayMs);
      }
    }

    document.getElementById('replay').addEventListener('click', buildHeart);
    document.getElementById('clear').addEventListener('click', () => { buildToken++; resetScene(); });

    addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') buildHeart();
      if (e.key === 'Escape') { buildToken++; resetScene(); }
    });

    addEventListener('resize', () => buildHeart(), { passive: true });

    buildHeart();
  </script>
</body>
</html>
