<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>给宝宝的小情书</title>

  <style>
    :root { color-scheme: dark; }

    html,body{
      height:100%;
      margin:0;
      overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      -webkit-tap-highlight-color: transparent;
    }

    body{
      min-height:100dvh;
      background:
        radial-gradient(900px 600px at 20% 10%, #2a1030 0%, transparent 55%),
        radial-gradient(900px 600px at 80% 20%, #0b2a3a 0%, transparent 55%),
        #05060a;
      color:#fff;
    }

    #layer{
      position:fixed;
      inset:0;
      height:100dvh;
      z-index:1;
    }

    /* 普遍手机（360~430px CSS宽）：更小弹窗+更小字 */
    :root{
      --popup-w: clamp(104px, 28vw, 150px);
      --popup-h: clamp(66px, 9.2vh, 98px);
      --bar-h: 26px;
      --radius: 12px;
      --font: clamp(10px, 1.12vh, 11.5px);
    }

    @media (min-width: 900px){
      :root{
        --popup-w: 180px;
        --popup-h: 110px;
        --bar-h: 32px;
        --radius: 14px;
        --font: 13.5px;
      }
    }

    .popup{
      position:fixed;
      width:var(--popup-w);
      height:var(--popup-h);
      border-radius:var(--radius);
      background:rgba(18,20,28,.84);
      border:2px solid rgba(255,255,255,.16);
      box-shadow:0 18px 55px rgba(0,0,0,.45);
      overflow:hidden;
      transform: translate(-50%, -50%);
      touch-action: manipulation;
      user-select:none;
    }

    .popup.dragging{ will-change:left, top, transform; }

    .popup.focused{
      outline:2px solid rgba(255,255,255,.16);
      box-shadow:0 22px 70px rgba(0,0,0,.55);
    }

    .bar{
      height:var(--bar-h);
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 8px 0 10px;
      background:rgba(255,255,255,.06);
      border-bottom:1px solid rgba(255,255,255,.10);
      font-size:12px;
      color:rgba(255,255,255,.85);
      cursor:grab;
      touch-action:none;
      user-select:none;
    }
    .bar:active{ cursor:grabbing; }

    .close{
      width:24px;
      height:24px;
      border-radius:9px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.10);
      color:#fff;
      cursor:pointer;
      display:grid;
      place-items:center;
      font-size:16px;
      line-height:1;
      padding:0;
    }

    .content{
      height: calc(var(--popup-h) - var(--bar-h));
      display:grid;
      place-items:center;
      padding:7px 9px;
      text-align:center;
      font-size:var(--font);
      color:rgba(255,255,255,.95);
      user-select:text;
    }

    .popIn{ animation: popIn .52s cubic-bezier(.2,.9,.2,1) both; }
    @keyframes popIn{
      from{ opacity:0; transform:translate(-50%,-50%) scale(.78); }
      to{ opacity:1; transform:translate(-50%,-50%) scale(1); }
    }

    @media (prefers-reduced-motion: reduce){
      .popIn{ animation:none; }
      .popup{ transition:none !important; }
    }

    .toolbar{
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: calc(12px + env(safe-area-inset-bottom));
      z-index: 2;
      display:flex;
      gap:10px;
      justify-content:center;
      pointer-events:none;
    }
    .toolbar button{
      pointer-events:auto;
      min-height: 44px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(15,23,42,.65);
      color:#fff;
      font-weight: 800;
      backdrop-filter: blur(10px);
    }
  </style>
</head>

<body>
  <div id="layer"></div>

  <div class="toolbar">
    <button id="replay">重播</button>
    <button id="clear">清空</button>
  </div>

  <script>
    const layer = document.getElementById('layer');

    const params = new URLSearchParams(location.search);
    const nickname = (params.get('name') || "宝宝").trim() || "宝宝";

    const isMobile = matchMedia('(pointer: coarse)').matches || innerWidth < 520;

    // 总数 200；轮廓阶段用更少的数量，才能“稀疏空灵”
    const totalPopups = Math.max(10, Number(params.get('total') || 200));
    const heartPopups = Math.min(
      totalPopups,
      Math.max(10, Number(params.get('heart') || (isMobile ? 72 : 160)))
    );

    // 越大越慢；手机默认更快一点（避免成型等待太久）
    const defaultSpeed = isMobile ? 45 : 80;
    const appearIntervalMs = Math.max(10, Number(params.get('speed') || defaultSpeed));

    // 先形成爱心，再散落（默认开启）
    const scatterEnabled = (params.get('scatter') ?? '1') !== '0';
    const scatterDelayMs = Math.max(0, Number(params.get('scatterDelay') || (isMobile ? 1100 : 1200)));
    const scatterDurationMs = Math.max(200, Number(params.get('scatterDuration') || (isMobile ? 900 : 1000)));

    // 散落后补齐到 totalPopups 的出现节奏
    const extraSpawnGapMs = Math.max(0, Number(params.get('extraGap') || (isMobile ? 12 : 8)));

    const words = [
      `好好吃饭，${nickname}，我会心疼。`,
      `早点睡觉，不许熬夜，听话。`,
      `我想你了，真的。`,
      `我刚刚又想你了…不止刚刚。`,
      `你忙你的，我乖乖想你。`,
      `我这边一切都好，就是有点想你。`,
      `想抱你一下，就一下也行。`,
      `你给我发条消息，我能开心一整天。`,
      `别逞强，难受就来找我。`,
      `你不说我也懂，但我还是想你说。`,
      `你今天有没有想我？我有。`,
      `我在等你忙完。`,
      `你一笑，我就什么都原谅了。`,
      `不开心就冲我撒娇，我接住。`,
      `喝水了吗？我监督你。`,
      `别皱眉，来，给你一个抱抱。`,
      `你出现以后，我的心就开始偏心了。`,
      `我想成为你最安心的那个人。`,
      `你别怕，我一直都在。`,
      `看到你名字，我就会忍不住笑。`,
      `如果想我了就直说，我会更开心。`,
      `我想你想得有点过分。`,
      `你别总是自己扛，我想参与。`,
      `到家跟我说一声，乖。`,
      `我对你，心软得一塌糊涂。`,
      `你靠近一点，我就投降。`,
      `别想太多，来想我。`,
      `你要记得：你有人惦记。`,
      `晚安，${nickname}，梦里也要想我。`,
    ];

    function rand(a, b) { return a + Math.random() * (b - a); }
    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function heartPoint(t) {
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
      return { x, y };
    }

    function borderColor() {
      const hue = Math.floor(rand(0, 360));
      return `hsl(${hue} 92% 65%)`;
    }

    let buildToken = 0;
    let timers = [];

    let topZ = 1000;
    function bringToFront(el) {
      topZ = Math.max(topZ + 1, Number(el.style.zIndex || 0) + 1);
      el.style.zIndex = String(topZ);
      el.classList.add('focused');
      setTimeout(() => el.classList.remove('focused'), 350);
    }

    function schedule(token, fn, ms) {
      const id = setTimeout(() => {
        if (token !== buildToken) return;
        fn();
      }, ms);
      timers.push(id);
    }

    function resetScene() {
      for (const id of timers) clearTimeout(id);
      timers = [];
      layer.replaceChildren();
    }

    function scatterPopups(token, popups, durationMs) {
      const margin = 10;

      for (const el of popups) {
        if (!el || !el.isConnected) continue;

        const rect = el.getBoundingClientRect();
        const halfW = rect.width / 2;
        const halfH = rect.height / 2;

        const x = rand(halfW + margin, innerWidth - halfW - margin);
        const y = rand(halfH + margin, innerHeight - halfH - margin);
        const rot = rand(-16, 16);

        el.style.transition =
          `left ${durationMs}ms cubic-bezier(.2,.9,.2,1), ` +
          `top ${durationMs}ms cubic-bezier(.2,.9,.2,1), ` +
          `transform ${durationMs}ms cubic-bezier(.2,.9,.2,1)`;

        requestAnimationFrame(() => {
          if (token !== buildToken || !el.isConnected) return;
          el.style.left = x + 'px';
          el.style.top = y + 'px';
          el.style.transform = `translate(-50%, -50%) scale(1) rotate(${rot}deg)`;
        });
      }

      schedule(token, () => {
        for (const el of popups) {
          if (!el || !el.isConnected) continue;
          el.style.transition = '';
        }
      }, durationMs + 40);
    }

    function makePopup({ cx, cy, text, z }) {
      const el = document.createElement('div');
      el.className = 'popup popIn';
      el.style.left = cx + 'px';
      el.style.top = cy + 'px';
      el.style.zIndex = String(z);
      el.style.borderColor = borderColor();
      topZ = Math.max(topZ, z);

      el.innerHTML = `
        <div class="bar">
          <span>♡ ${nickname}</span>
          <button class="close" aria-label="关闭">×</button>
        </div>
        <div class="content"></div>
      `;
      el.querySelector('.content').textContent = text;

      el.addEventListener('pointerdown', () => bringToFront(el), { passive: true });

      const closeBtn = el.querySelector('.close');
      closeBtn.addEventListener('pointerdown', (e) => e.stopPropagation(), { passive: true });
      closeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        el.remove();
      });

      const bar = el.querySelector('.bar');
      let dragging = false;
      let dx = 0, dy = 0;

      bar.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        dragging = true;
        el.classList.add('dragging');
        el.setPointerCapture(e.pointerId);

        bringToFront(el);
        el.style.transition = '';
        el.style.transform = 'translate(-50%, -50%) scale(1)';

        const rect = el.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        dx = e.clientX - centerX;
        dy = e.clientY - centerY;
      });

      el.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        const nextCx = clamp(e.clientX - dx, 20, innerWidth - 20);
        const nextCy = clamp(e.clientY - dy, 20, innerHeight - 20);
        el.style.left = nextCx + 'px';
        el.style.top = nextCy + 'px';
      });

      function stopDrag(){
        dragging = false;
        el.classList.remove('dragging');
      }
      el.addEventListener('pointerup', stopDrag);
      el.addEventListener('pointercancel', stopDrag);

      layer.appendChild(el);
      return el;
    }

    function measurePopupSize() {
      const probe = document.createElement('div');
      probe.className = 'popup';
      probe.style.left = '-9999px';
      probe.style.top = '-9999px';
      probe.style.visibility = 'hidden';
      probe.style.pointerEvents = 'none';
      probe.innerHTML = `
        <div class="bar"><span>♡</span><button class="close">×</button></div>
        <div class="content">test</div>
      `;
      document.body.appendChild(probe);
      const rect = probe.getBoundingClientRect();
      probe.remove();
      return { w: rect.width, h: rect.height };
    }

    function getHeartStats(samples = 720) {
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      let perimeter = 0;
      let prev = null;

      for (let i = 0; i <= samples; i++) {
        const t = (i / samples) * Math.PI * 2;
        const p = heartPoint(t);

        minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);

        if (prev) perimeter += Math.hypot(p.x - prev.x, p.y - prev.y);
        prev = p;
      }

      return {
        midX: (minX + maxX) / 2,
        midY: (minY + maxY) / 2,
        width: maxX - minX,
        height: maxY - minY,
        perimeter
      };
    }

    function buildHeart() {
      buildToken++;
      const token = buildToken;

      resetScene();

      const W = innerWidth;
      const H = innerHeight;

      const { w: popupW, h: popupH } = measurePopupSize();
      const margin = 10;

      // 预留底部按钮高度，避免挡住心形
      const bottomReserve = isMobile ? 96 : 0;

      // 手机：2 圈更饱满，但圈上点数少 => 更稀疏更空灵
      const rings = isMobile ? 2 : 3;
      const ringSpread = isMobile ? 0.10 : 0.06;
      const maxRingOffset = ((rings - 1) / 2) * ringSpread;

      const stats = getHeartStats(720);

      const usableW = Math.max(50, W - 2 * margin - popupW);
      const usableH = Math.max(50, (H - bottomReserve) - 2 * margin - popupH);

      // 关键：把弹窗尺寸算进去，保证心形“放得下”
      const scaleFit =
        0.98 *
        Math.min(usableW / stats.width, usableH / stats.height) /
        (1 + maxRingOffset);

      // 更稀疏：间距更大（越大越空灵）
      const baseSpacing = isMobile ? Math.max(popupW * 1.30, 42) : Math.max(popupW * 0.55, 26);
      const scaledPerimeter = stats.perimeter * scaleFit;

      // “物理上最多能放多少而不糊”
      const maxPerRingBySpacing = Math.floor(
        clamp(scaledPerimeter / baseSpacing, isMobile ? 12 : 35, isMobile ? 28 : 110)
      );

      // 把 heartPopups 平均分配到 rings
      const perRingTarget = Math.ceil(heartPopups / rings);
      const perRing = Math.floor(clamp(perRingTarget, isMobile ? 12 : 35, maxPerRingBySpacing));

      const pool = shuffle([...words]);
      let textIndex = 0;

      const created = [];
      let order = 0;

      const centerX = W / 2;
      const centerY = ((H - bottomReserve) / 2) + (isMobile ? 4 : 10);

      // 轮廓阶段：只创建 heartPopups 左右数量（稀疏好看）
      for (let r = 0; r < rings; r++) {
        const ringOffset = (r - (rings - 1) / 2) * ringSpread;
        const scale = scaleFit * (1 + ringOffset);

        for (let i = 0; i < perRing; i++) {
          const t = (i / perRing) * Math.PI * 2;
          const p = heartPoint(t);

          const jitter = isMobile ? 0 : Math.min(W, H) * 0.0025;

          const cx = centerX + (p.x - stats.midX) * scale + rand(-jitter, jitter);
          const cy = centerY - (p.y - stats.midY) * scale + rand(-jitter, jitter);

          const text = pool[textIndex++ % pool.length];
          const delay = order * appearIntervalMs;
          const z = 10 + order;
          order++;

          schedule(token, () => {
            created.push(makePopup({ cx, cy, text, z }));
          }, delay);
        }
      }

      const lastDelay = Math.max(0, (order - 1) * appearIntervalMs);

      // 成型后散落 + 补齐到 totalPopups(默认200)
      if (scatterEnabled) {
        schedule(token, () => {
          scatterPopups(token, created, scatterDurationMs);

          const need = Math.max(0, totalPopups - created.length);

          const halfW = popupW / 2;
          const halfH = popupH / 2;

          for (let k = 0; k < need; k++) {
            schedule(token, () => {
              const x = rand(halfW + margin, innerWidth - halfW - margin);
              const y = rand(halfH + margin, innerHeight - halfH - margin);
              const text = pool[textIndex++ % pool.length];
              makePopup({ cx: x, cy: y, text, z: 10 + order++ });
            }, k * extraSpawnGapMs);
          }
        }, lastDelay + scatterDelayMs);
      }
    }

    document.getElementById('replay').addEventListener('click', buildHeart);
    document.getElementById('clear').addEventListener('click', () => { buildToken++; resetScene(); });

    addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') buildHeart();
      if (e.key === 'Escape') { buildToken++; resetScene(); }
    });

    addEventListener('resize', () => buildHeart(), { passive: true });

    buildHeart();
  </script>
</body>
</html>
